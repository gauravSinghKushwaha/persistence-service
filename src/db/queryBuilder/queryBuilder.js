const conf = require('./../../config/config');
const log = require('./../../log/logger');
const crypt = require('./../../common/encrypt');

const DOT = ".";
const SPACE = " ";

function query(req, schema) {
    this.req = req;
    this.schema = schema;
    this.body = req.body;
    this.dbTable = this.body.table;
    this.dbSchema = this.body.schema;
    this.cols = this.body.attr;
    this.schemaCols = this.schema.properties.attr.properties;
    this.conf = this.schema.properties.conf;
}
/**
 * Based on column mentioned in body and schema, method creates conditions and values array for help building query
 */
query.prototype.createConditionsAndValues = function () {
    const conditions = [];
    const values = [];
    const strSchemaKeyArray = [];
    const schemaCols = this.schemaCols;
    const conf = this.conf;
    const colMap = buildMap(this.cols);
    const schemaColMap = buildMap(schemaCols);

    Object.keys(schemaCols).forEach(function (k) {
        strSchemaKeyArray.push(k.toString());
    });

    log.debug('cols= ' + JSON.stringify(this.cols) + '\t\tconf.hashobjs =' + JSON.stringify(conf.hashobjs) + '\t\tconf.encryptobjs = ' + JSON.stringify(conf.encryptobjs) +
        '\t\tconf.autoids = ' + JSON.stringify(conf.autoids) + '\t\tstrSchemaKeyArray = ' + strSchemaKeyArray + '\t\tschemaCols = ' + JSON.stringify(schemaCols));

    function isAutogenerated(k) {
        return contains(conf.autoids, k) || contains(conf.autodates, k);
    }

    strSchemaKeyArray.forEach(function (k) {
        //log.debug('k = ' + k + '\t\tcolMap.get(k) = ' + colMap.get(k) + '\t\t(schemaColMap.get(k).optional) = ' + (schemaColMap.get(k)).optional);
        const colValue = colMap.get(k) != null ? colMap.get(k) : (schemaColMap.get(k).optional != null ? schemaColMap.get(k).optional != null : null);
        if (colValue != null) {
            if (contains(conf.hashobjs, k)) {
                conditions.push(k);
                values.push(crypt.hashText(colMap.get(k) + ""));
            } else if (contains(conf.encryptobjs, k)) {
                conditions.push(k);
                values.push(crypt.encryptText(colMap.get(k) + ""));
            } else if (!isAutogenerated(k)) {
                conditions.push(k);
                values.push(contains(conf.dates, k) ? new Date(colMap.get(k)) : colMap.get(k));
            }
        }
    });
    return {"conditions": conditions, "values": values};
}
/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.createInsertQuery = function () {
    var queryStr = 'INSERT INTO ' + this.dbSchema + DOT + this.dbTable + SPACE + '(';
    const q = this.createConditionsAndValues.call(this);
    log.debug('condition values from input ' + q);
    queryStr += q.conditions.join(',') + ')' + SPACE + 'values(';
    q.values.forEach(function (val) {
        queryStr += '?,';
    });
    queryStr = queryStr.substr(0, queryStr.length - 1) + ')';
    log.debug('query : ' + queryStr);
    return {"query": queryStr, "values": q.values};
}

/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.updateQuery = function () {
    const conf = this.conf;
    var queryStr = 'UPDATE ' + this.dbSchema + DOT + this.dbTable + SPACE + 'SET' + SPACE;
    const q = this.createConditionsAndValues.call(this);
    log.debug('condition values from input ' + q);
    queryStr += q.conditions.join('= ? , ');
    queryStr += SPACE + ' = ? WHERE' + SPACE + conf.pk + ' = ?';
    q.values.push(this.req.params.id);
    return {"query": queryStr, "values": q.values};
}
/**
 * Checks obj presence in array
 * @param arr
 * @param obj
 * @returns {boolean}
 */
function contains(arr, obj) {
    return arr != null && arr.indexOf(obj) > -1;
}

/**
 * Building a map from object, key being toString of object key
 * @param obj
 * @returns {Map}
 */
function buildMap(obj) {
    const map = new Map();
    Object.keys(obj).forEach(function (key) {
        map.set(key.toString(), obj[key]);
    });
    return map;
}
module.exports = query;