const conf = require('./../../config/config');
const log = require('./../../log/logger');
const crypt = require('./../../common/encrypt');

const DOT = ".";
const SPACE = " ";

function query(req, res, resSchema) {
    this.req = req;
    this.res = res;
    this.resSchema = resSchema;
    this.body = req.body;
    this.dbTable = this.body.table;
    this.dbSchema = this.body.schema;
    this.cols = this.body.attr;
}
/**
 * Based on column mentioned in body and schema, method creates conditions and values array for help building query
 */
query.prototype.createConditionsAndValues = function () {
    const conditions = [];
    const values = [];
    const schemaCols = this.resSchema.properties.attr.properties;
    const colConf = this.body.conf;
    const colMap = buildMap(this.cols);
    const schemaColMap = buildMap(schemaCols);
    const strSchemaKeyArray = [];

    Object.keys(schemaCols).forEach(function (k) {
        strSchemaKeyArray.push(k.toString());
    });

    log.info('cols= ' + JSON.stringify(this.cols) + '\ncolConf.hashobjs =' + JSON.stringify(colConf.hashobjs) + '\ncolConf.encryptobjs = ' + JSON.stringify(colConf.encryptobjs) +
        '\ncolConf.autogenerated = ' + JSON.stringify(colConf.autogenerated) + '\nstrSchemaKeyArray = ' + strSchemaKeyArray + '\nschemaCols = ' + JSON.stringify(schemaCols));

    strSchemaKeyArray.forEach(function (k) {
        log.info('k = ' + k + '\ncolMap.get(k) = ' + colMap.get(k) + '\n(schemaColMap.get(k)) = ' + (schemaColMap.get(k)).optional);

        const colValue = colMap.get(k) != null ? colMap.get(k) : (schemaColMap.get(k).optional != null ? schemaColMap.get(k)[optional] != null : null);
        if (colValue != null) {
            if (colConf.hashobjs != null && contains(colConf.hashobjs, k)) {
                conditions.push(k);
                values.push(crypt.hashText(colMap.get(k) + ""));
            } else if (colConf.encryptobjs != null && contains(colConf.encryptobjs, k)) {
                conditions.push(k);
                values.push(crypt.encryptText(colMap.get(k) + ""));
            } else if (colConf.autogenerated == null || !contains(colConf.autogenerated, k)) {
                conditions.push(k);
                values.push(colMap.get(k));
            }
        }
    });
    return {"conditions": conditions, "values": values};
}
/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.createInsertQuery = function () {
    log.info('req =' + this.req.toString() + '\nres =' + this.res.toString() + '\nresSchema =' + JSON.stringify(this.resSchema) + '\nbody = '
        + JSON.stringify(this.body) + '\ndbTable= ' + this.dbTable + '\ndbSchema= ' + this.dbSchema);
    const queryStr = 'insert into ' + this.dbTable + DOT + this.dbSchema + SPACE + '(';

    const q = this.createConditionsAndValues.call(this);
    log.info(q);
    /*
     if (typeof params.name !== 'undefined') {
     conditions.push("name LIKE ?");
     values.push("%" + params.name + "%");
     }

     if (typeof params.age !== 'undefined') {
     conditions.push("age = ?");
     values.push(parseInt(params.age));
     }

     return {
     where: conditions.length ?
     conditions.join(' AND ') : '1',
     values: values
     }; */


}
/**
 * Checks obj presence in array
 * @param arr
 * @param obj
 * @returns {boolean}
 */
function contains(arr, obj) {
    return arr.indexOf(obj) > -1;
}

/**
 * Building a map from object, key being toString of object key
 * @param obj
 * @returns {Map}
 */
function buildMap(obj) {
    const map = new Map();
    Object.keys(obj).forEach(function (key) {
        map.set(key.toString(), obj[key]);
    });
    return map;
}
module.exports = query;