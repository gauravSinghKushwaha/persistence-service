const conf = require('./../../config/config');
const log = require('./../../log/logger');
const crypt = require('./../../common/encrypt');
const util = require('util');

const DOT = ".";
const SPACE = " ";
const SEMICOLON = ';';

/**
 * Query builder ; IF you update , check https://github.com/mysqljs/mysql for building effective and better queries
 * @param req
 * @param schema
 * @param conf
 */
function query(req, schema, conf) {
    this.req = req;
    if (this.req && this.req.body) {
        this.body = this.req.body;
        this.dbTable = this.body.table;
        this.dbSchema = this.body.schema;
        this.cols = this.body.attr;
    }
    this.schema = schema;
    if (!schema.properties.operation) {
        this.schemaCols = this.schema.properties.attr.properties;
    }
    this.conf = conf;
}

/**
 *  Encrypts value
 * @param conf SCHEMA_CONF
 * @param k CURRENT_KEY string value
 * @param rawValue RAW_VALUE non encrypted
 * @returns {*}
 */
query.prototype.getEncryptedValue = function (conf, k, rawValue, returnAutoGenerated) {
    var val = rawValue;
    if (contains(conf.hashed, k)) {
        val = crypt.hashText(rawValue + "");
    }

    if (contains(conf.encrypted, k)) {
        val = crypt.encryptText(rawValue + "");
    }

    if (contains(conf.dates, k)) {
        val = new Date(rawValue);
    }

    const blobConf = containsBlob(conf.blob, k);
    if (isValidObject(blobConf)) {
        if (blobConf.type == 'string') {
            val = new Buffer(val, 'utf8');
        }
    }
    // auto-generated like pk ids
    if (returnAutoGenerated && contains(conf.auto, k)) {
        val = rawValue;
    }
    return val;
};

query.prototype.hashValue = function (conf, k, rawValue) {
    if (contains(conf.hashed, k)) {
        return crypt.hashText(rawValue + "");
    }
    return rawValue;
};

query.prototype.decryptValues = function (results) {
    const conf = this.conf;
    for (l = 0; l < results.length; l++) {
        const obj = results[l];
        const keys = Object.keys(obj);
        for (m = 0; m < keys.length; m++) {
            const k = (keys[m]).toString();
            if (isValidObject(obj[k])) {
                const blobConf = containsBlob(conf.blob, k);
                if (isValidObject(blobConf) && blobConf.type == 'string') {
                    if (obj[k].type == 'Buffer') { // while caching at post we added via Json.String....which used buffer as it is
                        obj[k] = new Buffer(obj[k].data, 'utf8').toString();
                    } else {
                        obj[k] = obj[k].toString('utf8');
                    }
                }
                if (contains(conf.encrypted, k)) {
                    obj[k] = crypt.decryptText(obj[k]);
                }
            }
        }
    }
};


/**
 * Based on column mentioned in body and schema, method creates conditions and values array for help building query
 *
 * USED for both POST and PUT..so test both endpoint if you make any changes here
 */
query.prototype.createConditionsAndValues = function () {
    const conditions = [];
    const values = [];
    const strColKeyArray = [];
    const schemaCols = this.schemaCols;
    const conf = this.conf;
    // apart from bulk insert this will only have one object in array
    const colMap = buildMap(this.cols);
    // only one schema we support as of now
    const schemaColMap = buildMap(schemaCols)[0];

    log.debug('cols= ' + JSON.stringify(this.cols) + '\t\tconf.hashed =' + JSON.stringify(conf.hashed) + '\t\tconf.encrypted = ' + JSON.stringify(conf.encrypted) +
        '\t\tconf.autoids = ' + JSON.stringify(conf.autoids) + '\t\tschemaCols = ' + JSON.stringify(schemaCols));

    // taking column name from first data row in attr...all the subsequent need to have same column names
    const keys = Object.keys(util.isArray(this.cols) ? this.cols[0] : this.cols);
    for (j = 0; j < keys.length; j++) {
        const k = keys[j].toString();
        conditions.push(k);
    }
    for (f = 0; f < colMap.length; f++) {
        const cm = colMap[f];
        const val = [];
        for (h = 0; h < keys.length; h++) {
            const k = keys[h].toString();
            const colValue = cm.get(k) != null && cm.get(k) != undefined ? cm.get(k) : (schemaColMap.get(k).optional ? schemaColMap.get(k).optional : undefined);
            if (colValue) {
                val.push(this.getEncryptedValue(conf, k, colValue, false));
            }
        }
        values.push(val);
    }
    return {"conditions": conditions, "values": values};
};
/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.insertQuery = function () {
    const conf = this.conf;
    var queryStr = 'INSERT INTO ' + this.dbSchema + DOT + this.dbTable + SPACE + '(';
    const q = this.createConditionsAndValues();
    log.debug('condition values from input ' + q);
    if (isValidObject(this.req.params.id) && !contains(conf.auto, conf.key) && !contains(q.conditions, conf.key)) {
        q.conditions.push(conf.key);
        if (util.isArray(q.values)) {
            for (k = 0; k < q.values.length; k++) {
                const val = (q.values)[k];
                val.push(this.req.params.id);
            }
        } else {
            q.values.push(this.req.params.id);
        }
    }
    queryStr += q.conditions.join(',') + ')' + SPACE + ' VALUES ?';
    log.debug('query : ' + queryStr);
    return {
        "query": {
            sql: queryStr,
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": [q.values]
    };
};

function validateUpdatedFieldsAndWhereClause(conf, actualFields, where) {
    validateFields('Update', isValidObject(conf.updateconf) ? conf.updateconf.fields : [], actualFields);
    if (where) {
        validateFields('Where', conf.searchconf.where, Object.keys(where));
    }
}

/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.updateQuery = function () {
    const conf = this.conf;
    const jsonData = this.req.body;
    const fields = jsonData.attr;
    const where = jsonData.where;
    const actualFields = Object.keys(fields);

    validateUpdatedFieldsAndWhereClause(conf, actualFields, where);
    const q = this.createConditionsAndValues();
    log.debug('condition values from input ' + q);

    var queryStr = 'UPDATE ' + this.dbSchema + DOT + this.dbTable + SPACE + 'SET' + SPACE;
    queryStr += q.conditions.join('= ? , ');
    queryStr += SPACE + ' = ? WHERE' + SPACE + conf.key + ' = ?';

    // for update we should have only one row in array
    const values = (util.isArray(q.values) && q.values.length == 1) ? q.values[0] : q.values;
    values.push(this.req.params.id);

    console.log(JSON.stringify(queryStr));

    if (where) {
        console.log(JSON.stringify(queryStr));
        queryStr += SPACE + "AND" + SPACE;
        // adding where condition
        queryStr = addWhereConditionsToQuery.call(this, where, queryStr, values, conf);
    }
    console.log(JSON.stringify(queryStr));
    console.log(JSON.stringify(values));
    return {
        "query": {
            sql: queryStr,
            nestTables: isResultSetToBeNestedBasedOnTables(conf),
            timeout: getQueryTimeoutAtMySql(conf)
        },
        "values": values
    };
};

/**
 * Creates get query
 * @returns {{where: string, values: Array}}
 */
query.prototype.searchQuery = function () {
    const jsonData = this.req.body;
    const fields = jsonData.fields;
    const where = jsonData.where;
    const orderBy = jsonData.orderby;
    const limit = jsonData.limit;
    const offset = jsonData.offset;
    const conf = this.conf;
    const schema = this.dbSchema;
    const table = this.dbTable;
    const values = [];

    const isOrderingRequired = isOrderingByRequired(orderBy, conf);
    const validateInput = validateQueryObjectInputs(conf, fields, where, isOrderingRequired, orderBy);

    log.debug('Search validation =' + validateInput + '\nfields = ' + JSON.stringify(fields) + '\nwhere= ' + JSON.stringify(where) + '\norderBy = '
        + JSON.stringify(orderBy) + '\nlimit = ' + JSON.stringify(limit) + '\noffset = ' + offset);

    /**  maintain ordering to following query formation calls else DB query may not form correct*/
    var queryStr = addSelectFieldsToQuery(fields, schema, table);
    queryStr = addWhereConditionsToQuery.call(this, where, queryStr, values, conf);
    queryStr = addOrederingToQuery(isOrderingRequired, queryStr, orderBy, conf);
    queryStr = limitNoOfEntitiesFromQuery(queryStr, limit, conf.searchconf.resultlimit);
    queryStr = addOffsetToQuery(offset, queryStr);

    return {
        "query": {
            sql: queryStr,
            nestTables: isResultSetToBeNestedBasedOnTables(conf),
            timeout: getQueryTimeoutAtMySql(conf)
        },
        "values": values
    };
};

function isResultSetToBeNestedBasedOnTables(conf) {
    return conf.query && conf.query.nesttables ? conf.query.nesttables : false;
}

function getQueryTimeoutAtMySql(conf) {
    return conf.query && conf.query.timeout ? conf.query.timeout : 60000;
}

function isOrderingByRequired(orderby, conf) {
    return isValidObject(orderby) && conf.searchconf.orderby && orderby.order && conf.searchconf.orderby.order;
}

function validateOrderyClause(isOrderingRequired, conf, orderby) {
    return ((isOrderingRequired) ? validateFields('OrderBy', conf.searchconf.orderby.order, orderby.order) : true);
}

function validateQueryObjectInputs(conf, fields, where, isOrderingRequired, orderby) {
    return validateFields('Search', conf.searchconf.fields, fields) && validateFields('Where', conf.searchconf.where, Object.keys(where))
        && validateOrderyClause(isOrderingRequired, conf, orderby);
}

function buildInClauseOfWhereCondition(queryStr, wheObj, values, conf, k) {
    queryStr = queryStr + ' IN (';
    for (j = 0; j < wheObj.length; j++) {
        queryStr = queryStr + (j < wheObj.length - 1 ? ' ? ,' : ' ? ');
        values.push(this.getEncryptedValue(conf, k.toString(), wheObj[j], true));
    }
    queryStr = queryStr + ' )';
    return queryStr;
}

function buildEqualClauseOfWhereCondition(queryStr, values, conf, k, valueObj) {
    values.push(this.getEncryptedValue(conf, k.toString(), valueObj, true));
    return queryStr + ' = ? ';
}

function addUserDefinedOrderingToQuery(queryStr, orderby) {
    return queryStr + SPACE + 'ORDER BY' + SPACE + orderby.order.join(',') + SPACE + (orderby.by != null && orderby.by != undefined ? orderby.by : 'ASC') + SPACE;
}

function addDefaultOrderingToQuery(queryStr, conf) {
    return queryStr + SPACE + ((conf.searchconf && conf.searchconf.orderby && conf.searchconf.orderby.deforder) ? (' ORDER BY' + SPACE + conf.searchconf.orderby.deforder ) : '');
}

function addOrederingToQuery(isOrderingRequired, queryStr, orderby, conf) {
    if (isOrderingRequired) {
        queryStr = addUserDefinedOrderingToQuery(queryStr, orderby);
    } else { // default ordering if any
        queryStr = addDefaultOrderingToQuery(queryStr, conf);
    }
    return queryStr;
}

function limitNoOfEntitiesFromQuery(queryStr, limit, defLimit) {
    return queryStr + SPACE + 'LIMIT' + SPACE + (  limit ? limit : (defLimit ? defLimit : 10)) + SPACE;
}

function addOffsetToQuery(offset, queryStr) {
    if (offset) {
        queryStr = queryStr + SPACE + 'OFFSET' + SPACE + offset + SPACE;
    }
    return queryStr;
}

function addWhereConditionsToQuery(where, queryStr, values, conf) {
    const keys = Object.keys(where);
    for (var i = 0; i < keys.length; i++) {
        const k = keys[i];
        const valueObj = where[k];
        queryStr = queryStr + k;
        if (util.isArray(valueObj)) {
            queryStr = buildInClauseOfWhereCondition.call(this, queryStr, valueObj, values, conf, k);
        } else {
            queryStr = buildEqualClauseOfWhereCondition.call(this, queryStr, values, conf, k, valueObj);
        }
        queryStr = queryStr + (i < keys.length - 1 ? ' AND ' : SPACE);
    }
    return queryStr;
}

function addSelectFieldsToQuery(fields, dbSchema, dbTable) {
    return 'SELECT ' + SPACE + fields.join(',') + SPACE + 'FROM' + SPACE + dbSchema + DOT + dbTable + SPACE + 'WHERE' + SPACE;
}

/**
 * Find resource by ID
 * @param table
 * @param schema
 * @param id
 */
query.prototype.findById = function (table, schema, id) {
    const conf = this.conf;
    const q = {
        "query": {
            sql: 'SELECT ' + SPACE + conf.searchconf.fields.join(',') + SPACE + 'FROM' + SPACE + schema + '.' + table + SPACE + 'WHERE ' + conf.key + ' = ? ' + ((conf.searchconf && conf.searchconf.orderby && conf.searchconf.orderby.deforder) ? (' ORDER BY' + SPACE + conf.searchconf.orderby.deforder ) : ''),
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": [id]
    };
    return q;
};

/**
 * Find resource by ID
 * @param table
 * @param schema
 * @param id
 */
query.prototype.deleteById = function (table, schema, id) {
    return {
        "query": {
            sql: 'DELETE FROM ' + schema + '.' + table + SPACE + 'WHERE ' + this.conf.key + ' = ? ',
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": [id]
    };
};

/**
 * Get and delet...two queries, two values
 * @param table
 * @param schema
 * @param id
 * @returns {{query: string, values: [*]}}
 */
query.prototype.getanddelete = function (table, schema, id) {
    const getQuery = this.findById(table, schema, id);
    const deleteQuery = this.deleteById(table, schema, id);

    return {
        "query": {
            sql: getQuery.query.sql + SEMICOLON + deleteQuery.query.sql,
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": [getQuery.values, deleteQuery.values]
    };
};

/**
 * Creates get query
 * @returns {{where: string, values: Array}}
 */
query.prototype.deleteQuery = function () {
    const jsonData = this.req.body;
    const where = jsonData.where;
    const conf = this.conf;
    const values = [];

    const validateInput = validateFields('Where', conf.deleteconf.where, Object.keys(where));
    log.debug('Search validation =' + validateInput + '\nwhere= ' + JSON.stringify(where));
    const DELETE = 'DELETE';
    const SELECT = 'SELECT' + SPACE + this.conf.key.toString();
    var deleteQuery = DELETE + SPACE + 'FROM' + SPACE + this.dbSchema + DOT + this.dbTable + SPACE + 'WHERE' + SPACE;
    const keys = Object.keys(where);
    deleteQuery = deleteQuery + keys.join(' = ? AND ') + ' = ? ' + SPACE;

    for (i = 0; i < keys.length; i++) {
        const k = keys[i];
        values.push(this.getEncryptedValue(conf, k.toString(), where[k], true));
    }

    const selectIds = deleteQuery.replace(DELETE, SELECT);
    return {
        "query": {
            sql: selectIds + SEMICOLON + deleteQuery,
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": [values, values]
    };
};


/**
 * if present then update and create a new resource
 */
query.prototype.putifpresent = function () {
    const q = this.insertQuery();
    q.values.push(this.req.params.id);
    q.query = q.query + SPACE + 'ON DUPLICATE KEY UPDATE' + SPACE + this.conf.key + ' = ?';
    return {
        "query": {
            sql: q.query,
            nestTables: conf.query && conf.query.nesttables ? conf.query.nesttables : false,
            timeout: conf.query && conf.query.timeout ? conf.query.timeout : 60000
        },
        "values": q.values
    };
};

/**
 * Checks obj presence in array
 * @param blobArr array of objects {
      "col": "xml",
      "type": "string"
    }
 * @param col name
 * @returns {boolean}
 */
function containsBlob(blobArr, obj) {
    if (blobArr != undefined && blobArr != null && blobArr.length > 0) {
        for (i = 0; i < blobArr.length; i++) {
            if (blobArr[i].col == obj) {
                return blobArr[i];
            }
        }
    }
}

function isValidObject(obj) {
    return obj != null && obj != undefined && Object.keys(obj).length > 0;
}

/**
 * Checks obj presence in array
 * @param arr
 * @param obj
 * @returns {boolean}
 */
function contains(arr, obj) {
    return isLegalArray(arr) && arr.indexOf(obj) > -1;
}

function isLegalArray(subArray) {
    return subArray != null && subArray != undefined && subArray.length > 0;
}

/**
 * true if all the elements of subArray are in array
 * @param array
 * @param subArray
 */
function containsArray(array, subArray) {
    if (isLegalArray(array)
        && isLegalArray(subArray) && array.length >= subArray.length) {
        for (i = 0; i < subArray.length; i++) {
            if (!contains(array, subArray[i])) {
                return false;
            }
        }
        return true;
    }
}

function validateFields(clause, allowedFields, actualFields) {
    if (!containsArray(allowedFields, actualFields)) {
        throw new Error(isLegalArray(allowedFields) ? clause + ' only allowed on ' + JSON.stringify(allowedFields) : 'update not allowed');
    }
    return true;
}

/**
 * Building a map from object, key being toString of object key
 * @param obj
 * @returns {Map}
 */
function buildMap(obj) {
    const li = [];
    if (util.isArray(obj)) {
        for (g = 0; g < obj.length; g++) {
            var map = new Map();
            var o = obj[g];
            var keys = Object.keys(o);
            for (h = 0; h < keys.length; h++) {
                var key = keys[h];
                map.set(key.toString(), o[key]);
            }
            li.push(map);
        }
    } else {
        const map = new Map();
        const keys = Object.keys(obj);
        for (h = 0; h < keys.length; h++) {
            const key = keys[h];
            map.set(key.toString(), obj[key]);
        }
        li.push(map);
    }
    return li;
}

module.exports = query;
