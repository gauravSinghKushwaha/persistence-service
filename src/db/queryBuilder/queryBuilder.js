const conf = require('./../../config/config');
const log = require('./../../log/logger');
const crypt = require('./../../common/encrypt');

const DOT = ".";
const SPACE = " ";

function query(req, schema) {
    this.req = req;
    this.schema = schema;
    this.body = req.body;
    this.dbTable = this.body.table;
    this.dbSchema = this.body.schema;
    this.cols = this.body.attr;
}
/**
 * Based on column mentioned in body and schema, method creates conditions and values array for help building query
 */
query.prototype.createConditionsAndValues = function () {
    const conditions = [];
    const values = [];
    const schemaCols = this.schema.properties.attr.properties;
    const colConf = this.body.conf;
    const colMap = buildMap(this.cols);
    const schemaColMap = buildMap(schemaCols);
    const strSchemaKeyArray = [];

    Object.keys(schemaCols).forEach(function (k) {
        strSchemaKeyArray.push(k.toString());
    });

    log.debug('cols= ' + JSON.stringify(this.cols) + '\ncolConf.hashobjs =' + JSON.stringify(colConf.hashobjs) + '\ncolConf.encryptobjs = ' + JSON.stringify(colConf.encryptobjs) +
        '\ncolConf.autogenerated = ' + JSON.stringify(colConf.autogenerated) + '\nstrSchemaKeyArray = ' + strSchemaKeyArray + '\nschemaCols = ' + JSON.stringify(schemaCols));

    strSchemaKeyArray.forEach(function (k) {
        log.debug('k = ' + k + '\ncolMap.get(k) = ' + colMap.get(k) + '\n(schemaColMap.get(k).optional) = ' + (schemaColMap.get(k)).optional);
        console.log('k = ' + k + '\ncolMap.get(k) = ' + colMap.get(k) + '\n(schemaColMap.get(k).optional) = ' + (schemaColMap.get(k)).optional);
        const colValue = colMap.get(k) != null ? colMap.get(k) : (schemaColMap.get(k).optional != null ? schemaColMap.get(k).optional != null : null);
        if (colValue != null) {
            if (colConf.hashobjs != null && contains(colConf.hashobjs, k)) {
                conditions.push(k);
                values.push(crypt.hashText(colMap.get(k) + ""));
            } else if (colConf.encryptobjs != null && contains(colConf.encryptobjs, k)) {
                conditions.push(k);
                values.push(crypt.encryptText(colMap.get(k) + ""));
            } else if (colConf.autogenerated == null || !contains(colConf.autogenerated, k)) {
                conditions.push(k);
                values.push(colMap.get(k));
            }
        }
    });
    return {"conditions": conditions, "values": values};
}
/**
 * Creates insert query
 * @returns {{where: string, values: Array}}
 */
query.prototype.createInsertQuery = function () {
    log.debug('req =' + this.req.toString() + '\nresSchema =' + JSON.stringify(this.schema) + '\nbody = '
        + JSON.stringify(this.body) + '\ndbTable= ' + this.dbTable + '\ndbSchema= ' + this.dbSchema);
    var queryStr = 'insert into ' + this.dbSchema + DOT + this.dbTable + SPACE + '(';
    const q = this.createConditionsAndValues.call(this);
    log.debug('condition values from input ' + q);
    queryStr += q.conditions.join(',') + ')' + SPACE + 'values(';
    q.values.forEach(function (val) {
        queryStr += '?,';
    });
    console.log(queryStr);
    queryStr = queryStr.substr(0, queryStr.length - 1) + ')';
    log.debug('query : ' + queryStr);
    return {"query": queryStr, "values": q.values};
}
/**
 * Checks obj presence in array
 * @param arr
 * @param obj
 * @returns {boolean}
 */
function contains(arr, obj) {
    return arr.indexOf(obj) > -1;
}

/**
 * Building a map from object, key being toString of object key
 * @param obj
 * @returns {Map}
 */
function buildMap(obj) {
    const map = new Map();
    Object.keys(obj).forEach(function (key) {
        map.set(key.toString(), obj[key]);
    });
    return map;
}
module.exports = query;